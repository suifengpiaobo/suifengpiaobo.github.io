<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[设计模式-单例模式]]></title>
    <url>%2F2018%2F12%2F02%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F-1%2F</url>
    <content type="text"><![CDATA[单例模式(创建型模式):单例模式的意图是为了确保一个类有且仅有一个实例，并为它提供一个全局的访问点。优点1、在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例2、避免对资源的多重占用 实现方式饿汉式方式1:1234567891011public class Singleton &#123; //在类内部实例化一个实例 private static Singleton instance = new Singleton(); //私有的构造函数,外部无法访问 private Singleton() &#123; &#125; //对外提供获取实例的静态方法 public static Singleton getInstance() &#123; return instance; &#125;&#125; 简单的单例的实现，这种实现方式我们称之为饿汉式。所谓饿汉。这是个比较形象的比喻。对于一个饿汉来说，他希望他想要用到这个实例的时候就能够立即拿到，而不需要任何等待时间。所以，通过static的静态初始化方式，在该类第一次被加载的时候实例被创建出来了。这样就保证在第一次想要使用该对象时，他已经被初始化好了。由于该实例在类被加载的时候就创建出来了，所以也避免了线程安全问题。方式2123456789101112131415public class Singleton &#123; //在类内部定义 private static Singleton instance; static &#123; //实例化该实例 instance = new Singleton(); &#125; //私有的构造函数,外部无法访问 private Singleton() &#123; &#125; //对外提供获取实例的静态方法 public static Singleton getInstance() &#123; return instance; &#125;&#125; 与方式1是一样的，都是在类被加载的时候实例化一个对象.饿汉式单例，在类被加载的时候对象就会实例化。这也许会造成不必要的消耗，因为有可能这个实例根本就不会被用到。而且，如果这个类被多次加载的话也会造成多次实例化。静态内部类方式12345678910111213public class StaticInnerSingleton &#123; //在静态内部类中初始化实例对象 private static class InnerSingleton &#123; private static final StaticInnerSingleton INSTANCE = new StaticInnerSingleton(); &#125; //私有的构造方法 private StaticInnerSingleton() &#123; &#125; //对外提供获取实例的静态方法 public static final StaticInnerSingleton getInstance() &#123; return InnerSingleton.INSTANCE; &#125;&#125; 这种方式同样利用了classloder的机制来保证初始化instance时只有一个线程，它跟饿汉式不同的是（很细微的差别）：饿汉式是只要Singleton类被装载了，那么instance就会被实例化（没有达到lazy loading效果），而这种方式是Singleton类被装载了，instance不一定被初始化。因为InnerSingleton类没有被主动使用，只有显示通过调用getInstance方法时，才会显示装载InnerSingleton类，从而实例化instance。想象一下，如果实例化instance很消耗资源，我想让他延迟加载，另外一方面，我不希望在Singleton类加载时就实例化，因为我不能确保Singleton类还可能在其他的地方被主动使用从而被加载，那么这个时候实例化instance显然是不合适的。这个时候，这种方式相比饿汉式更加合理。 懒汉式该对象真正被使用的时候才会实例化的单例模式——懒汉模式。1234567891011121314public class Singleton &#123; //定义实例 private static Singleton instance; //私有构造方法 private Singleton()&#123;&#125; //对外提供获取实例的静态方法 public static Singleton getInstance() &#123; //在对象被使用的时候才实例化 if (instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125;&#125; 懒汉，就是不会提前把实例创建出来，将类对自己的实例化延迟到第一次被引用的时候。getInstance方法的作用是希望该对象在第一次被使用的时候被new出来。懒汉式单例其实还存在一个问题，那就是线程安全问题。在多线程情况下，有可能两个线程同时进入if语句中，这样，在两个线程都从if中退出的时候就创建了两个不一样的对象。线程安全的懒汉式1234567891011121314public class SynchronizedSingleton &#123; //定义实例 private static SynchronizedSingleton instance; //私有构造方法 private SynchronizedSingleton()&#123;&#125; //对外提供获取实例的静态方法,对该方法加锁 public static synchronized SynchronizedSingleton getInstance() &#123; //在对象被使用的时候才实例化 if (instance == null) &#123; instance = new SynchronizedSingleton(); &#125; return instance; &#125;&#125; 这种写法能够在多线程中很好的工作，而且看起来它也具备很好的延迟加载，但是，遗憾的是，他效率很低，因为99%情况下不需要同步。（因为上面的synchronized的加锁范围是整个方法，该方法的所有操作都是同步进行的，但是对于非第一次创建对象的情况，也就是没有进入if语句中的情况，根本不需要同步操作，可以直接返回instance。）双重校验锁相信对并发编程了解的同学都知道如何解决。其实上面的代码存在的问题主要是锁的范围太大了。只要缩小锁的范围就可以了。那么如何缩小锁的范围呢？相比于同步方法，同步代码块的加锁范围更小。123456789101112131415public class Singleton &#123; private static Singleton singleton; private Singleton() &#123; &#125; public static Singleton getSingleton() &#123; if (singleton == null) &#123; synchronized (Singleton.class) &#123; if (singleton == null) &#123; singleton = new Singleton(); &#125; &#125; &#125; return singleton; &#125;&#125; 通过使用同步代码块的方式减小了锁的范围。这样可以大大提高效率。（对于已经存在singleton的情况，无须同步，直接return）。但是，事情这的有这么容易吗？上面的代码看上去好像是没有任何问题。实现了惰性初始化，解决了同步问题，还减小了锁的范围，提高了效率。但是，该代码还存在隐患。隐患的原因主要和Java内存模型（JMM）有关。考虑下面的事件序列：1、 线程A发现变量没有被初始化, 然后它获取锁并开始变量的初始化。2、 由于某些编程语言的语义，编译器生成的代码允许在线程A执行完变量的初始化之前，更新变量并将其指向部分初始化的对象。3、 线程B发现共享变量已经被初始化，并返回变量。由于线程B确信变量已被初始化，它没有获取锁。如果在A完成初始化之前共享变量对B可见（这是由于A没有完成初始化或者因为一些初始化的值还没有穿过B使用的内存(缓存一致性)），程序很可能会崩溃。在J2SE 1.4或更早的版本中使用双重检查锁有潜在的危险，有时会正常工作（区分正确实现和有小问题的实现是很困难的。取决于编译器，线程的调度和其他并发系统活动，不正确的实现双重检查锁导致的异常结果可能会间歇性出现。重现异常是十分困难的。） 在J2SE 5.0中，这一问题被修正了。volatile关键字保证多个线程可以正确处理单件实例使用volatile123456789101112131415public class VolatileSingleton &#123; private static volatile VolatileSingleton singleton; private VolatileSingleton() &#123; &#125; public static VolatileSingleton getSingleton() &#123; if (singleton == null) &#123; synchronized (VolatileSingleton.class) &#123; if (singleton == null) &#123; singleton = new VolatileSingleton(); &#125; &#125; &#125; return singleton; &#125;&#125; 上面这种双重校验锁的方式用的比较广泛，他解决了前面提到的所有问题。但是，即使是这种看上去完美无缺的方式也可能存在问题，那就是遇到序列化的时候。使用final123456class FinalWrapper&lt;T&gt; &#123; public final T value; public FinalWrapper(T value) &#123; this.value = value; &#125;&#125; 123456789101112131415public class FinalSingleton &#123; private FinalWrapper&lt;FinalSingleton&gt; helperWrapper = null; public FinalSingleton getHelper() &#123; FinalWrapper&lt;FinalSingleton&gt; wrapper = helperWrapper; if (wrapper == null) &#123; synchronized (this) &#123; if (helperWrapper == null) &#123; helperWrapper = new FinalWrapper&lt;FinalSingleton&gt;(new FinalSingleton()); &#125; wrapper = helperWrapper; &#125; &#125; return wrapper.value; &#125;&#125; 枚举式12345public enum Singleton &#123; INSTANCE; public void Singleton() &#123; &#125;&#125; 这种方式是Effective Java作者Josh Bloch 提倡的方式，它不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象（下面会介绍），可谓是很坚强的壁垒啊，在深度分析Java的枚举类型—-枚举的线程安全性及序列化问题中有详细介绍枚举的线程安全问题和序列化问题，不过，个人认为由于1.5中才加入enum特性，用这种方式写不免让人感觉生疏，在实际工作中，我也很少看见有人这么写过，但是不代表他不好。单例与序列化在单例与序列化的那些事儿一文中，Hollis就分析过单例和序列化之前的关系——序列化可以破坏单例。要想防止序列化对单例的破坏，只要在Singleton类中定义readResolve就可以解决该问题：1234567891011121314151617public class Singleton implements Serializable&#123; private volatile static Singleton singleton; private Singleton ()&#123;&#125; public static Singleton getSingleton() &#123; if (singleton == null) &#123; synchronized (Singleton.class) &#123; if (singleton == null) &#123; singleton = new Singleton(); &#125; &#125; &#125; return singleton; &#125; private Object readResolve() &#123; return singleton; &#125;&#125;]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法]]></title>
    <url>%2F2018%2F12%2F02%2F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式-设计模式概述]]></title>
    <url>%2F2018%2F12%2F02%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[设计模式的六大原则1、开闭原则（Open Close Principle）开闭原则就是说对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。 2、里氏代换原则（Liskov Substitution Principle）里氏代换原则(Liskov Substitution Principle LSP)面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。 LSP是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。里氏代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。 3、依赖倒转原则（Dependence Inversion Principle）这个是开闭原则的基础，具体内容：真对接口编程，依赖于抽象而不依赖于具体。 4、接口隔离原则（Interface Segregation Principle）这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。还是一个降低类之间的耦合度的意思，从这儿我们看出，其实设计模式就是一个软件的设计思想，从大型软件架构出发，为了升级和维护方便。所以上文中多次出现：降低依赖，降低耦合。 5、迪米特法则（最少知道原则）（Demeter Principle）为什么叫最少知道原则，就是说：一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。 6、合成复用原则（Composite Reuse Principle）合成复用原则是尽量使用合成/聚合的方式，而不是使用继承。其中前四种也是面向对象的四个基本原则。 设计模式分类设计模式分为5种类型:接口型模式: 适配器模式、外观模式 、合成模式、桥接模式指责型模式: 单例模式、观察者模式、调停者模式、代理模式、职责链模式、享元模式构造型模式: 构建着模式、工厂方法模式、抽象工厂模式、原型模式、备忘录模式操作型模式: 模板方法模式、状态模式、策略模式、命令模式、解释器模式扩展型模式: 装饰器模式、迭代器模式、访问者模式。 设计模式简单介绍抽象工厂模式（Abstract Factory）: 提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。适配器模式（Adapter）: 将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。桥接模式（Bridge）: 将抽象部分与它的实现部分分离，使它们都可以独立地变化。建造者模式（Builder）: 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。责任链模式（Chain of Responsibility）: 为解除请求的发送者和接收者之间耦合，而使多个对象都有机会处理这个请求。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它。命令模式（Command）: 将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可取消的操作。组合模式（Composite）: 将对象组合成树形结构以表示“部分-整体”的层次结构。它使得客户对单个对象和复合对象的使用具有一致性。装饰模式（Decorator）: 动态地给一个对象添加一些额外的职责。就扩展功能而言， 它比生成子类方式更为灵活。外观模式（Facade）: 为子系统中的一组接口提供一个一致的界面，Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。工厂模式（Factory Method）: 定义一个用于创建对象的接口，让子类决定将哪一个类实例化。Factory Method使一个类的实例化延迟到其子类。享元模式（Flyweight）: 运用共享技术有效地支持大量细粒度的对象。解析器模式（Interpreter）: 给定一个语言, 定义它的文法的一种表示，并定义一个解释器, 该解释器使用该表示来解释语言中的句子。迭代器模式（Iterator）: 提供一种方法顺序访问一个聚合对象中各个元素，而又不需暴露该对象的内部表示。中介模式（Mediator）: 用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。备忘录模式（Memento）: 在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到保存的状态。观察者模式（Observer）: 定义对象间的一种一对多的依赖关系,以便当一个对象的状态发生改变时,所有依赖于它的对象都得到通知并自动刷新。原型模式（Prototype）: 用原型实例指定创建对象的种类，并且通过拷贝这个原型来创建新的对象。代理模式（Proxy）: 为其他对象提供一个代理以控制对这个对象的访问。单例模式（Singleton）: 保证一个类仅有一个实例，并提供一个访问它的全局访问点。状态模式（State）: 允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它所属的类。策略模式（Strategy）: 定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。本模式使得算法的变化可独立于使用它的客户。模板方法模式（Template Method）: 定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。Template Method使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。访问者模式（Visitor）: 表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
</search>
