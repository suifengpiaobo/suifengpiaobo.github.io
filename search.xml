<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[全面了解Activity]]></title>
    <url>%2F2018%2F12%2F04%2F%E5%85%A8%E9%9D%A2%E4%BA%86%E8%A7%A3Activity%2F</url>
    <content type="text"><![CDATA[Activity是什么？我们都知道android中有四大组件（Activity 活动，Service 服务，Content Provider 内容提供者，BroadcastReceiver 广播接收器），Activity是我们用的最多也是最基本的组件，因为应用的所有操作都与用户相关，Activity 提供窗口来和用户进行交互。 官方文档这么说： An activity is a single, focused thing that the user can do. Almost all activities interact with the user, so the Activity class takes care of creating a window for you in which you can place your UI with setContentView(View). 大概的意思（原谅我）：activity是独立平等的，用来处理用户操作。几乎所有的activity都是用来和用户交互的，所以activity类会创建了一个窗口，开发者可以通过setContentView(View)的接口把UI放到给窗口上。 Android中的activity全都归属于task管理 。task 是多个 activity 的集合，这些 activity 按照启动顺序排队存入一个栈（即“back stack”）。android默认会为每个App维持一个task来存放该app的所有activity，task的默认name为该app的packagename。 当然我们也可以在AndroidMainfest.xml中申明activity的taskAffinity属性来自定义task，但不建议使用，如果其他app也申明相同的task，它就有可能启动到你的activity，带来各种安全问题（比如拿到你的Intent）。 Activity的内部调用过程 上面已经说了，系统通过堆栈来管理activity，当一个新的activity开始时，它被放置在堆栈的顶部和成为运行活动，以前的activity始终保持低于它在堆栈，而不会再次到达前台，直到新的活动退出。还是上这张官网的activity_lifecycle图：首先打开一个新的activity实例的时候，系统会依次调用onCreate（） -&gt; onStart() -&gt; onResume() 然后开始runningrunning的时候被覆盖了（从它打开了新的activity或是被锁屏，但是它依然在前台运行， lost focus but is still visible），系统调用onPause(); 该方法执行activity暂停，通常用于提交未保存的更改到持久化数据，停止动画和其他的东西。但这个activity还是完全活着（它保持所有的状态和成员信息，并保持连接到窗口管理器） 接下来它有三条出路①用户返回到该activity就调用onResume()方法重新running ②用户回到桌面或是打开其他activity，就会调用onStop()进入停止状态（保留所有的状态和成员信息，对用户不可见） ③系统内存不足，拥有更高限权的应用需要内存，那么该activity的进程就可能会被系统回收。（回收onRause()和onStop()状态的activity进程）要想重新打开就必须重新创建一遍。 如果用户返回到onStop()状态的activity（又显示在前台了），系统会调用 onRestart() -&gt; onStart() -&gt; onResume() 然后重新running 在activity结束（调用finish ()）或是被系统杀死之前会调用onDestroy()方法释放所有占用的资源。 activity生命周期中三个嵌套的循环 activity的完整生存期会在 onCreate() 调用和 onDestroy() 调用之间发生。 activity的可见生存期会在 onStart() 调用和 onStop() 调用之间发生。系统会在activity的整个生存期内多次调用 onStart() 和onStop()， 因为activity可能会在显示和隐藏之间不断地来回切换。 activity的前后台切换会在 onResume() 调用和 onPause() 之间发生。 因为这个状态可能会经常发生转换，为了避免切换迟缓引起的用户等待，这两个方法中的代码应该相当地轻量化。activity被回收的状态和信息保存和恢复过程12345678910111213141516171819202122232425262728public class MainActivity extends Activity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; if(savedInstanceState!=null)&#123; //判断是否有以前的保存状态信息 savedInstanceState.get("Key"); &#125; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); &#125; @Override protected void onSaveInstanceState(Bundle outState) &#123; // TODO Auto-generated method stub //可能被回收内存前保存状态和信息， Bundle data = new Bundle(); data.putString("key", "last words before be kill"); outState.putAll(data); super.onSaveInstanceState(outState); &#125; @Override protected void onRestoreInstanceState(Bundle savedInstanceState) &#123; // TODO Auto-generated method stub if(savedInstanceState!=null)&#123; //判断是否有以前的保存状态信息 savedInstanceState.get("Key"); &#125; super.onRestoreInstanceState(savedInstanceState); &#125;&#125; onSaveInstanceState方法 在activity 可能被回收之前 调用,用来保存自己的状态和信息，以便回收后重建时恢复数据（在onCreate()或onRestoreInstanceState()中恢复）。旋转屏幕重建activity会调用该方法，但其他情况在onRause()和onStop()状态的activity不一定会调用 ，下面是该方法的文档说明。 One example of when onPause and onStop is called and not this method is when a user navigates back from activity B to activity A: there is no need to call onSaveInstanceState on B because that particular instance will never be restored, so the system avoids calling it. An example when onPause is called and not onSaveInstanceState is when activity B is launched in front of activity A:the system may avoid calling onSaveInstanceState on activity A if it isn’t killed during the lifetime of B since the state of the user interface of A will stay intact.也就是说，系统灵活的来决定调不调用该方法，但是如果要调用就一定发生在onStop方法之前，但并不保证发生在onPause的前面还是后面。onRestoreInstanceState方法这个方法在onStart 和 onPostCreate之间调用，在onCreate中也可以状态恢复，但有时候需要所有布局初始化完成后再恢复状态。onPostCreate：一般不实现这个方法，当程序的代码开始运行时，它调用系统做最后的初始化工作。 启动模式启动模式什么？简单的说就是定义activity 实例与task 的关联方式。 为什么要定义启动模式？为了实现一些默认启动（standard）模式之外的需求： 让某个 activity 启动一个新的 task （而不是被放入当前 task ）让 activity 启动时只是调出已有的某个实例（而不是在 back stack 顶创建一个新的实例） 或者，你想在用户离开 task 时只保留根 activity，而 back stack 中的其它 activity 都要清空 怎样定义启动模式？定义启动模式的方法有两种：使用 manifest 文件在 manifest 文件中activity声明时，利用 activity 元素的 launchMode 属性来设定 activity 与 task 的关系。123456&lt;activity ．．．．．． android:launchMode="standard" &gt; ．．．．．．．&lt;/activity&gt; 注意： 你用 launchMode 属性为 activity 设置的模式可以被启动 activity 的 intent 标志所覆盖。 有哪些启动模式？“standard” （默认模式）当通过这种模式来启动Activity时, Android总会为目标 Activity创建一个新的实例,并将该Activity添加到当前Task栈中。这种方式不会启动新的Task,只是将新的 Activity添加到原有的Task中。 “singleTop”该模式和standard模式基本一致,但有一点不同:当将要被启动的Activity已经位于Task栈顶时,系统不会重新创建目标Activity实例,而是直接复用Task栈顶的Activity。“singleTask”Activity在同一个Task内只有一个实例。 如果将要启动的Activity不存在,那么系统将会创建该实例,并将其加入Task栈顶； 如果将要启动的Activity已存在,且存在栈顶,直接复用Task栈顶的Activity。 如果Activity存在但是没有位于栈顶,那么此时系统会把位于该Activity上面的所有其他Activity全部移出Task,从而使得该目标Activity位于栈顶。“singleInstance”无论从哪个Task中启动目标Activity,只会创建一个目标Activity实例且会用一个全新的Task栈来装载该Activity实例（全局单例）.如果将要启动的Activity不存在,那么系统将会先创建一个全新的Task,再创建目标Activity实例并将该Activity实例放入此全新的Task中。如果将要启动的Activity已存在,那么无论它位于哪个应用程序,哪个Task中;系统都会把该Activity所在的Task转到前台,从而使该Activity显示出来。使用 Intent 标志在要启动 activity 时，你可以在传给 startActivity() 的 intent 中包含相应标志，以修改 activity 与 task 的默认关系。123Intent i = new Intent(this,ＮewActivity.class);i.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);startActivity(i); ##可以通过标志修改的默认模式有哪些？FLAG_ACTIVITY_NEW_TASK与”singleTask”模式相同，在新的 task 中启动 activity。如果要启动的 activity 已经运行于某 task 中，则那个 task 将调入前台。FLAG_ACTIVITY_SINGLE_TOP与 “singleTop”模式相同，如果要启动的 activity位于back stack 顶，系统不会重新创建目标Activity实例,而是直接复用Task栈顶的Activity。FLAG_ACTIVITY_CLEAR_TOP此种模式在launchMode中没有对应的属性值。如果要启动的 activity 已经在当前 task 中运行，则不再启动一个新的实例，且所有在其上面的 activity 将被销毁。 ##关于启动模式的一些建议一般不要改变 activity 和 task 默认的工作方式。 如果你确定有必要修改默认方式，请保持谨慎，并确保 activity 在启动和从其它 activity 返回时的可用性，多做测试和安全方面的工作。 #Intent Filterandroid的3个核心组件——Activity、services、广播接收器——是通过intent传递消息的。intent消息用于在运行时绑定不同的组件。 在 Android 的 AndroidManifest.xml 配置文件中可以通过 intent-filter 节点为一个 Activity 指定其 Intent Filter，以便告诉系统该 Activity 可以响应什么类型的 Intent。 ##intent-filter 的三大属性Action一个 Intent Filter 可以包含多个 Action，Action 列表用于标示 Activity 所能接受的“动作”，它是一个用户自定义的字符串。12345&lt;intent-filter &gt; &lt;action android:name="android.intent.action.MAIN" /&gt; &lt;action android:name="com.scu.amazing7Action" /&gt; …… &lt;/intent-filter&gt; 在代码中使用以下语句便可以启动该Intent 对象：12Intent i=new Intent(); i.setAction("com.scu.amazing7Action"); Action 列表中包含了“com.scu.amazing7Action”的 Activity 都将会匹配成功URL在 intent-filter 节点中，通过 data节点匹配外部数据，也就是通过 URI 携带外部数据给目标组件。12345&lt;data android:mimeType="mimeType" android:scheme="scheme" android:host="host" android:port="port" android:path="path"/&gt; 注意：只有data的所有的属性都匹配成功时 URI 数据匹配才会成功Category为组件定义一个 类别列表，当 Intent 中包含这个类别列表的所有项目时才会匹配成功。1234&lt;intent-filter . . . &gt; &lt;action android:name="code android.intent.action.MAIN" /&gt; &lt;category android:name="code android.intent.category.LAUNCHER" /&gt;&lt;/intent-filter&gt; Activity和Intent Filter 的匹配过程①加载所有的Intent Filter列表 ②去掉action匹配失败的Intent Filter ③去掉url匹配失败的Intent Filter ④去掉Category匹配失败的Intent Filter ⑤判断剩下的Intent Filter数目是否为0。如果为0查找失败返回异常；如果大于0，就按优先级排序，返回最高优先级的Intent Filter #开发中Activity的一些问题一般设置Activity为非公开的123&lt;activity ．．．．．． android:exported="false" /&gt; 注意：非公开的Activity不能设置intent-filter，以免被其他activity唤醒（如果拥有相同的intent-filter）。 不要指定activity的taskAffinity属性 不要设置activity的LaunchMode（保持默认） 注意Activity的intent最好也不要设定为FLAG_ACTIVITY_NEW_TASK 在匿名内部类中使用this时加上activity类名（类名.this,不一定是当前activity） 设置activity全屏在其 onCreate()方法中加入：1234// 设置全屏模式 getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN, WindowManager.LayoutParams.FLAG_FULLSCREEN); // 去除标题栏 requestWindowFeature(Window.FEATURE_NO_TITLE);]]></content>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试题-Android]]></title>
    <url>%2F2018%2F12%2F03%2F%E9%9D%A2%E8%AF%95%E9%A2%98-Android%2F</url>
    <content type="text"><![CDATA[Android 源码中的设计模式 面向对象的六大原则1、 单一职责原则 所谓职责是指类变化的原因。如果一个类有多于一个的动机被改变，那么这个类就具有多于一个的职责。而单一职责原则就是指一个类或者模块应该有且只有一个改变的原因。通俗的说，即一个类只负责一项职责，将一组相关性很高的函数、数据封装到一个类中。 2、 开闭原则 对于扩展是开放的，这意味着模块的行为是可以扩展的。当应用的需求改变时，我们可以对模块进行扩展，使其具有满足那些改变的新行为。 对于修改是关闭的，对模块行为进行扩展时，不必改动模块的源代码。 通俗的说，尽量通过扩展的方式实现系统的升级维护和新功能添加，而不是通过修改已有的源代码。 3、 里氏替换原则 使用“抽象(Abstraction)”和“多态(Polymorphism)”将设计中的静态结构改为动态结构，维持设计的封闭性。任何基类可以出现的地方，子类一定可以出现。 在软件中将一个基类对象替换成它的子类对象，程序将不会产生任何错误和异常，反过来则不成立。在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象。 4、 依赖倒置原则 高层次的模块不应该依赖于低层次的模块，他们都应该依赖于抽象。抽象不应该依赖于具体实现，具体实现应该依赖于抽象。 程序要依赖于抽象接口，不要依赖于具体实现。简单的说就是要求对抽象进行编程，不要对实现进行编程，这样就降低了客户与实现模块间的耦合（各个模块之间相互传递的参数声明为抽象类型，而不是声明为具体的实现类）。 5、 接口隔离原则 一个类对另一个类的依赖应该建立在最小的接口上。其原则是将非常庞大的、臃肿的接口拆分成更小的更具体的接口。 6、 迪米特原则 又叫作最少知识原则，就是说一个对象应当对其他对象有尽可能少的了解。 通俗地讲，一个类应该对自己需要耦合或调用的类知道得最少，不关心被耦合或调用的类的内部实现，只负责调用你提供的方法。 下面开始设计模式学习．．． Singleton（单例模式）作用： 保证在Java应用程序中，一个类Class只有一个实例存在。 好处： 由于单例模式在内存中只有一个实例，减少了内存开销。 单例模式可以避免对资源的多重占用，例如一个写文件时，由于只有一个实例存在内存中，避免对同一个资源文件的同时写操作。 单例模式可以再系统设置全局的访问点，优化和共享资源访问。 使用情况：建立目录 数据库连接的单线程操作某个需要被频繁访问的实例对象 使用方法第一种形式：123456789101112131415public class Singleton &#123; /* 持有私有静态实例，防止被引用，此处赋值为null，目的是实现延迟加载 */ private static Singleton instance = null; /* 私有构造方法，防止被实例化 */ private Singleton() &#123; &#125; /* 懒汉式：第一次调用时初始Singleton，以后就不用再生成了 静态方法，创建实例 */ public static Singleton getInstance() &#123; if (instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125;&#125; 但是这有一个问题，不同步啊！在对据库对象进行的频繁读写操作时，不同步问题就大了。第二种形式：既然不同步那就给getInstance方法加个锁呗！我们知道使用synchronized关键字可以同步方法和同步代码块，所以：123456public static synchronized Singleton getInstance() &#123; if (instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125; 或是12345678public static Singleton getInstance() &#123; synchronized (Singleton.class) &#123; if (instance == null) &#123; instance = new Singleton(); &#125; &#125; return instance; &#125; android中的Singleton软键盘管理的 InputMethodManager源码1234567891011121314public final class InputMethodManager &#123;//.........static InputMethodManager sInstance;//.........public static InputMethodManager getInstance() &#123; synchronized (InputMethodManager.class) &#123; if (sInstance == null) &#123; IBinder b = ServiceManager.getService(Context.INPUT_METHOD_SERVICE); IInputMethodManager service = IInputMethodManager.Stub.asInterface(b); sInstance = new InputMethodManager(service, Looper.getMainLooper()); &#125; return sInstance; &#125;&#125; 使用的是第二种同步代码块的单例模式（可能涉及到多线程），类似的还有AccessibilityManager（View获得点击、焦点、文字改变等事件的分发管理，对整个系统的调试、问题定位等）BluetoothOppManager等。当然也有 同步方法的单例 实现，比如：CalendarDatabaseHelper123456public static synchronized CalendarDatabaseHelper getInstance(Context context) &#123; if (sSingleton == null) &#123; sSingleton = new CalendarDatabaseHelper(context); &#125; return sSingleton;&#125; 注意Application并不算是单例模式1234public class Application extends ContextWrapper implements ComponentCallbacks2 &#123; public Application() &#123; super(null);&#125; 在Application源码中，其构造方法是公有的，意味着可以生出多个Application实例，但为什么Application能实现一个app只存在一个实例呢？请看下面：在ContextWrapper源码中：1234567891011public class ContextWrapper extends Context &#123;Context mBase;public ContextWrapper(Context base) &#123; mBase = base;&#125;protected void attachBaseContext(Context base) &#123; if (mBase != null) &#123; throw new IllegalStateException("Base context already set"); &#125; mBase = base;&#125; ContextWrapper构造函数传入的base为null, 就算有多个Application实例，但是没有通过attach()绑定相关信息，没有上下文环境，三个字。 Factory（工厂模式）定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。对同一个接口的实现类进行管理和实例化创建假设我们有这样一个需求： 动物Animal，它有行为move()。有两个实现类cat和dog。为了统一管理和创建我们设计一个工厂模式。 同时两个子类有各自的行为，Cat有eatFish()，Dog有eatBone().Animal接口：123interface animal &#123; void move();&#125; Cat类：1234567891011public class Cat implements Animal&#123; @Override public void move() &#123; // TODO Auto-generated method stub System.out.println("我是只肥猫，不爱动"); &#125; public void eatFish() &#123; System.out.println("爱吃鱼"); &#125; &#125; Dog类:1234567891011public class Dog implements Animal&#123; @Override public void move() &#123; // TODO Auto-generated method stub System.out.println("我是狗，跑的快"); &#125; public void eatBone() &#123; System.out.println("爱吃骨头"); &#125; &#125; 那么现在就可以建一个工厂类（Factory.java）来对实例类进行管理和创建了.1234567891011public class Factory &#123; //静态工厂方法 //多处调用，不需要实例工厂类 public static Cat produceCat() &#123; return new Cat(); &#125; public static Dog produceDog() &#123; return new Dog(); &#125;//当然也可以一个方法，通过传入参数，switch实现&#125; 使用：123456Animal cat = Factory.produceCat();cat.move();//-----------------------------Dog dog = Factory.produceDog();dog.move();dog.eatBone(); 工厂模式在业界运用十分广泛，如果都用new来生成对象，随着项目的扩展，animal还可以生出许多其他儿子来，当然儿子还有儿子，同时也避免不了对以前代码的修改（比如加入后来生出儿子的实例）,怎么管理，想着就是一团糟。1Animal cat = Factory.produceCat(); 这里实例化了Animal但不涉及到Animal的具体子类（减少了它们之间的偶合联系性），达到封装效果，也就减少错误修改的机会。 Java面向对象的原则，封装(Encapsulation)和分派(Delegation)告诉我们：具体事情做得越多，越容易范错误, 一般来说，这样的普通工厂就可以满足基本需求。但是我们如果要新增一个Animal的实现类panda，那么必然要在工厂类里新增了一个生产panda的方法。就违背了 闭包的设计原则（对扩展要开放对修改要关闭） ，于是有了抽象工厂模式。 Abstract Factory(抽象工厂)抽象工厂模式提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。啥意思？就是把生产抽象成一个接口，每个实例类都对应一个工厂类（普通工厂只有一个工厂类），同时所有工厂类都继承这个生产接口。 生产接口Provider：123interface Provider &#123; Animal produce(); &#125; 每个产品都有自己的工厂 CatFactory：12345678public class CatFactory implements Provider&#123; @Override public Animal produce() &#123; // TODO Auto-generated method stub return new Cat(); &#125;&#125; DogFactory：12345678public class DogFactory implements Provider&#123; @Override public Animal produce() &#123; // TODO Auto-generated method stub return new Dog(); &#125;&#125; 产品生产：123Provider provider = new CatFactory();Animal cat =provider.produce();cat.move(); 现在我们要加入panda，直接新建一个pandaFactory就行了，这样我们系统就非常灵活，具备了动态扩展功能。Android中的Factory比如AsyncTask的抽象工厂实现：工厂的抽象：1234public interface ThreadFactory &#123;//省略为备注 Thread newThread(Runnable r);&#125; 产品的抽象（new Runnable就是其实现类）：1234public interface Runnable &#123;//省略为备注 public abstract void run();&#125; AsyncTask中工厂类的实现：123456private static final ThreadFactory sThreadFactory = new ThreadFactory() &#123;private final AtomicInteger mCount = new AtomicInteger(1); public Thread newThread(Runnable r) &#123; return new Thread(r, "AsyncTask #" + mCount.getAndIncrement()); &#125;&#125;; 我们可以创建另外类似的工厂，生产某种专门的线程（多线程），非常容易扩展。 当然，android中的应用还有很多（比如BitmapFactory），有兴趣的小伙伴可以去扒一扒。 Adapter（适配器模式）将一个类的接口转换成客户希望的另外一个接口。我们经常碰到要将两个没有关系的类组合在一起使用，第一解决方案是：修改各自类的接口，但是如果我们没有源代码，或者，我们不愿意为了一个应用而修改各自的接口。 怎么办?使用Adapter，在这两种接口之间创建一个混合接口。模式中的角色需要适配的类（Adaptee）：需要适配的类。适配器（Adapter）：通过包装一个需要适配的对象，把原接口转换成目标接口。目标接口（Target）：客户所期待的接口。可以是具体的或抽象的类，也可以是接口。1234567891011// 需要适配的类 class Adaptee &#123; public void specificRequest() &#123; System.out.println("需要适配的类"); &#125; &#125; // 目标接口 interface Target &#123; public void request(); &#125; 实现方式：①、对象适配器（采用对象组合方式实现）123456789101112131415161718192021222324// 适配器类实现标准接口class Adapter implements Target&#123; // 直接关联被适配类 private Adaptee adaptee; // 可以通过构造函数传入具体需要适配的被适配类对象 public Adapter (Adaptee adaptee) &#123; this.adaptee = adaptee; &#125; public void request() &#123; // 这里是使用委托的方式完成特殊功能 this.adaptee.specificRequest(); &#125;&#125;// 测试类public class Client &#123; public static void main(String[] args) &#123; // 需要先创建一个被适配类的对象作为参数 Target adapter = new Adapter(new Adaptee()); adapter.request(); &#125;&#125; 如果Target不是接口而是一个具体的类的情况，这里的Adapter直接继承Target就可以了。 ②、类的适配器模式（采用继承实现）12345678910111213// 适配器类继承了被适配类同时实现标准接口 class Adapter extends Adaptee implements Target&#123; public void request() &#123; super.specificRequest(); &#125; &#125; // 测试类public static void main(String[] args) &#123; // 使用适配类 Target adapter = new Adapter(); adapter.request(); &#125; 如果Target和 Adaptee都是接口，并且都有实现类。 可以通过Adapter实现两个接口来完成适配。还有一种叫PluggableAdapters,可以动态的获取几个adapters中一个。使用Reflection技术，可以动态的发现类中的Public方法。优点系统需要使用现有的类，而此类的接口不符合系统的需要。那么通过适配器模式就可以让这些功能得到更好的复用。 将目标类和适配者类解耦，通过引入一个适配器类重用现有的适配者类，而无需修改原有代码，更好的扩展性。缺点过多的使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是A接口，其实内部被适配成了B接口的实现。如果不是必要，不要使用适配器，而是直接对系统进行重构。Android中的Adapterandroid中的Adapter就有很多了，这个大家都经常用。Adapter是AdapterView视图与数据之间的桥梁，Adapter提供对数据的访问，也负责为每一项数据产生一个对应的View。BaseAdapter的部分源码：1234567891011public abstract class BaseAdapter implements ListAdapter, SpinnerAdapter &#123;private final DataSetObservable mDataSetObservable = new DataSetObservable();public boolean hasStableIds() &#123; return false;&#125; public void registerDataSetObserver(DataSetObserver observer) &#123; mDataSetObservable.registerObserver(observer);&#125;public void unregisterDataSetObserver(DataSetObserver observer) &#123; mDataSetObservable.unregisterObserver(observer);&#125; ListAdapter, SpinnerAdapter都是Target ，数据是Adaptee ，采用对象组合方式。 Chain of Responsibility（责任链模式）使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。发出这个请求的客户端并不知道链上的哪一个对象最终处理这个请求，这使得系统可以在不影响客户端的情况下动态地重新组织和分配责任。 编程中的小体现：123456789101112if(a&lt;10)&#123; ...&#125;else if (a&lt;20）&#123; ...&#125;else if(a&lt;30)&#123; ...&#125;else&#123; ...&#125; 程序必须依次扫描每个分支进行判断，找到对应的分支进行处理。责任链模式的优点可以降低系统的耦合度（请求者与处理者代码分离），简化对象的相互连接，同时增强给对象指派职责的灵活性，增加新的请求处理类也很方便；责任链模式的缺点不能保证请求一定被接收，且对于比较长的职责链，请求的处理可能涉及到多个处理对象，系统性能将受到一定影响，而且在进行代码调试时不太方便。 每次都是从链头开始，这也正是链表的缺点Android中的Chain of Responsibility触摸、按键等各种事件的传递有兴趣的可以看一下View事件分发机制源码分析，我这就不多说了。 Observer（观察者模式）有时被称作发布/订阅模式，观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态发生变化时，会通知所有观察者对象，使它们能够自动更新自己。将一个系统分割成一个一些类相互协作的类有一个不好的副作用，那就是需要维护相关对象间的一致性。我们不希望为了维持一致性而使各类紧密耦合，这样会给维护、扩展和重用都带来不便。观察者就是解决这类的耦合关系的（依赖关系并未完全解除，抽象通知者依旧依赖抽象的观察者。）。观察者模式的组成①抽象主题（Subject）它把所有观察者对象的引用保存到一个聚集里，每个主题都可以有任何数量的观察者。抽象主题提供一个接口，可以增加和删除观察者对象。②具体主题（ConcreteSubject）将有关状态存入具体观察者对象；在具体主题内部状态改变时，给所有登记过的观察者发出通知。③抽象观察者（Observer）为所有的具体观察者定义一个接口，在得到主题通知时更新自己。④具体观察者（ConcreteObserver）实现抽象观察者角色所要求的更新接口，以便使本身的状态与主题状态协调。123456//抽象观察者public interface Observer&#123; public void update(String str); &#125; 12345678//具体观察者public class ConcreteObserver implements Observer&#123; @Override public void update(String str) &#123; // TODO Auto-generated method stub System.out.println(str); &#125;&#125; 1234567//抽象主题public interface Subject&#123; public void addObserver(Observer observer); public void removeObserver(Observer observer); public void notifyObservers(String str);&#125; 123456789101112131415161718192021222324//具体主题public class ConcreteSubject implements Subject&#123; // 存放观察者 private List&lt;Observer&gt; list = new ArrayList&lt;Observer&gt;(); @Override public void addObserver(Observer observer) &#123; // TODO Auto-generated method stub list.add(observer); &#125; @Override public void removeObserver(Observer observer) &#123; // TODO Auto-generated method stub list.remove(observer); &#125; @Override public void notifyObservers(String str) &#123; // TODO Auto-generated method stub for(Observer observer:list)&#123; observer.update(str); &#125; &#125;&#125; 下面是测试类：1234567891011121314public class Test &#123; public static void main(String[] args) &#123; //一个主题 ConcreteSubject eatSubject = new ConcreteSubject(); //两个观察者 ConcreteObserver personOne = new ConcreteObserver(); ConcreteObserver personTwo = new ConcreteObserver(); //观察者订阅主题 eatSubject.addObserver(personOne); eatSubject.addObserver(personTwo); //通知开饭了 eatSubject.notifyObservers("开饭啦"); &#125;&#125; Android中的Observer观察者模式在android中运用的也比较多，最熟悉的ContentObserver。① 抽象类ContentResolver中（Subject）注册观察者：1public final void registerContentObserver(Uri uri, boolean notifyForDescendents,ContentObserver observer, int userHandle) 取消观察者：1public final void unregisterContentObserver(ContentObserver observer) 抽象类ContentObserver中（Observer）123456789public void onChange(boolean selfChange) &#123; // Do nothing. Subclass should override.&#125;public void onChange(boolean selfChange, Uri uri, int userId) &#123; onChange(selfChange, uri);&#125;public void onChange(boolean selfChange, Uri uri) &#123; onChange(selfChange);&#125; 观察特定Uri引起的数据库的变化，继而做一些相应的处理（最终都调用的第一个函数）．② DataSetObserver，其实这个我们一直在用，只是没意识到。我们再看到BaseAdapter的部分源码：123456public void registerDataSetObserver(DataSetObserver observer) &#123; mDataSetObservable.registerObserver(observer);&#125;public void unregisterDataSetObserver(DataSetObserver observer) &#123; mDataSetObservable.unregisterObserver(observer);&#125; 上面两个方法分别向向BaseAdater注册、注销一个DataSetObserver实例。DataSetObserver 的源码：12345678public abstract class DataSetObserver &#123; public void onChanged() &#123; // Do nothing &#125; public void onInvalidated() &#123; // Do nothing &#125;&#125; DataSetObserver就是一个观察者，它一旦发现BaseAdapter内部数据有变量，就会通过回调方法DataSetObserver.onChanged和DataSetObserver.onInvalidated来通知DataSetObserver的实现类。 Builder（建造者模式）建造者模式：是将一个复杂的对象的构建与它的表示分离（同构建不同表示），使得同样的构建过程可以创建不同的表示。将复杂的内部创建封装在内部，对于外部调用的人来说，只需要传入建造者和建造工具，对于内部是如何建造成成品的，调用者无需关心。建造者模式通常包括下面几个角色：① Builder：一个抽象接口，用来规范产品对象的各个组成成分的建造。② ConcreteBuilder：实现Builder接口，针对不同的商业逻辑，具体化复杂对象的各部分的创建，在建造过程完成后，提供产品的实例。③ Director：指导者，调用具体建造者来创建复杂对象的各个部分，不涉及具体产品的信息，只负责保证对象各部分完整创建或按某种顺序创建。④ Product：要创建的复杂对象。与抽象工厂的区别：在建造者模式里，有个指导者，由指导者来管理建造者，用户是与指导者联系的，指导者联系建造者最后得到产品。即建造模式可以强制实行一种分步骤进行的建造过程。Product和产品的部分Part接口12public interface Product &#123; &#125;public interface Part &#123; &#125; Builder：12345public interface Builder &#123; void buildPartOne(); void buildPartTwo(); Product getProduct(); &#125; ConcreteBuilder:12345678910111213//具体建造工具public class ConcreteBuilder implements Builder &#123; Part partOne, partTwo; public void buildPartOne() &#123; //具体构建代码 &#125;; public void buildPartTwo() &#123; //具体构建代码 &#125;; public Product getProduct() &#123; //返回最后组装的产品 &#125;; &#125; Director :12345678910public class Director &#123; private Builder builder; public Director( Builder builder ) &#123; this.builder = builder; &#125; public void construct() &#123; builder.buildPartOne(); builder.buildPartTwo(); &#125; &#125; 建造：12345ConcreteBuilder builder = new ConcreteBuilder();Director director = new Director(builder); //开始各部分建造 director.construct(); Product product = builder.getResult(); 优点：客户端不必知道产品内部组成的细节。具体的建造者类之间是相互独立的，对系统的扩展非常有利。由于具体的建造者是独立的，因此可以对建造过程逐步细化，而不对其他的模块产生任何影响。使用场合：创建一些复杂的对象时，这些对象的内部组成构件间的建造顺序是稳定的，但是对象的内部组成构件面临着复杂的变化。要创建的复杂对象的算法，独立于该对象的组成部分，也独立于组成部分的装配方法时。Android中的Builderandroid中的Dialog就使用了Builder Pattern，下面来看看AlertDialog的部分源码。12345678public static class Builder &#123; private final AlertController.AlertParams P; private int mTheme; public Builder(Context context, int theme) &#123; P = new AlertController.AlertParams(new ContextThemeWrapper( context, resolveDialogTheme(context, theme))); mTheme = theme;&#125; AlertDialog的Builder是一个静态内部类，没有定义Builder的抽象接口。对AlertDialog设置的属性会保存在Build类的成员变量P（AlertController.AlertParams）中。Builder类中部分方法：1234public Builder setTitle(int titleId) &#123; P.mTitle = P.mContext.getText(titleId); return this;&#125; 1234public Builder setMessage(int messageId) &#123; P.mMessage = P.mContext.getText(messageId); return this;&#125; 12345public Builder setPositiveButton(CharSequence text, final OnClickListener listener) &#123; P.mPositiveButtonText = text; P.mPositiveButtonListener = listener; return this;&#125; 而show()方法会返回一个结合上面设置的dialog实例12345public AlertDialog show() &#123; AlertDialog dialog = create(); dialog.show(); return dialog;&#125; 1234567891011121314public AlertDialog create() &#123; final AlertDialog dialog = new AlertDialog(P.mContext, mTheme, false); P.apply(dialog.mAlert); dialog.setCancelable(P.mCancelable); if (P.mCancelable) &#123; dialog.setCanceledOnTouchOutside(true); &#125; dialog.setOnCancelListener(P.mOnCancelListener); dialog.setOnDismissListener(P.mOnDismissListener); if (P.mOnKeyListener != null) &#123; dialog.setOnKeyListener(P.mOnKeyListener); &#125; return dialog;&#125; 简单建造：12345new AlertDialog.Builder(context) .setTitle("标题") .setMessage("消息框") .setPositiveButton("确定", null) .show(); Memento（备忘录模式）备忘录模式又叫做快照模式(Snapshot Pattern)或Token模式，是对象的行为模式。备忘录对象是一个用来存储另外一个对象内部状态的快照的对象。备忘录模式的用意是在不破坏封装的条件下，将一个对象的状态捕捉(Capture)住，并外部化，存储起来，从而可以在将来合适的时候把这个对象还原到存储起来的状态。备忘录模式常常与命令模式和迭代子模式一同使用。 备忘录模式所涉及的角色有三个：① Originator(发起人):负责创建一个备忘录Memento，用以记录当前时刻它的内部状态，并可使用备忘录恢复内部状态。Originator可根据需要决定Memento存储Originator的哪些内部状态。② Memento(备忘录):负责存储Originnator对象的内部状态，并可防止Originator以外的其他对象访问备忘录Memento，备忘录有两个接口，Caretaker只能看到备忘录的窄接口，它只能将备忘录传递给其他对象。③、Caretaker(管理者):负责保存好备忘录Memento，不能对备忘录的内容进行操作或检查。12345678910111213141516171819202122232425public class Originator &#123; private String state; /** * 工厂方法，返回一个新的备忘录对象 */ public Memento createMemento()&#123; return new Memento(state); &#125; /** * 将发起人恢复到备忘录对象所记载的状态 */ public void restoreMemento(Memento memento)&#123; this.state = memento.getState(); &#125; public String getState() &#123; return state; &#125; public void setState(String state) &#123; this.state = state; System.out.println("当前状态：" + this.state); &#125;&#125; 1234567891011121314151617public class Memento &#123; private String state; public Memento(String state)&#123; this.state = state; &#125; public String getState() &#123; return state; &#125; public void setState(String state) &#123; this.state = state; &#125; &#125; 12345678910111213141516public class Caretaker &#123; private Memento memento; /** * 备忘录的取值方法 */ public Memento retrieveMemento()&#123; return this.memento; &#125; /** * 备忘录的赋值方法 */ public void saveMemento(Memento memento)&#123; this.memento = memento; &#125;&#125; 使用：12345678910Originator o = new Originator();Caretaker c = new Caretaker();//改变负责人对象的状态o.setState("On");//创建备忘录对象，并将发起人对象的状态储存起来 c.saveMemento(o.createMemento());//修改发起人的状态o.setState("Off");//恢复发起人对象的状态 o.restoreMemento(c.retrieveMemento()); 不需要了解对象的内部结构的情况下备份对象的状态，方便以后恢复。 Android中的MementoActivity的onSaveInstanceState和onRestoreInstanceState就是通过Bundle（相当于备忘录对象）这种序列化的数据结构来存储Activity的状态，至于其中存储的数据结构，这两个方法不用关心。源码：12345678protected void onSaveInstanceState(Bundle outState) &#123; outState.putBundle(WINDOW_HIERARCHY_TAG, mWindow.saveHierarchyState()); Parcelable p = mFragments.saveAllState(); if (p != null) &#123; outState.putParcelable(FRAGMENTS_TAG, p); &#125; getApplication().dispatchActivitySaveInstanceState(this, outState);&#125; 12345678protected void onRestoreInstanceState(Bundle savedInstanceState) &#123; if (mWindow != null) &#123; Bundle windowState = savedInstanceState.getBundle(WINDOW_HIERARCHY_TAG); if (windowState != null) &#123; mWindow.restoreHierarchyState(windowState); &#125; &#125;&#125; Prototype（原型模式）原型模式，能快速克隆出一个与已经存在对象类似的另外一个我们想要的新对象。 工作原理是：通过将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象通过请求原型对象拷贝它们自己来实施创建。分为深拷贝和浅拷贝。深拷贝就是把对象里面的引用的对象也要拷贝一份新的对象，并将这个新的引用对象作为拷贝的对象引用（多读两遍）。一般使用原型模式有个明显的特点，就是实现cloneable的clone()方法。 在Intent源码中：1234@Overridepublic Object clone() &#123; return new Intent(this);&#125; 这里Intent通过实现Cloneable接口来实现原型拷贝。 Strategy（策略模式）定义：有一系列的算法，将每个算法封装起来（每个算法可以封装到不同的类中），各个算法之间可以替换，策略模式让算法独立于使用它的客户而独立变化。举例： 一个影碟机，你往里面插什么碟子，就能放出什么电影。 属性动画，设置不同的插值器对象，就可以得到不同的变化曲线。返回值解析，传入什么样的解析器，就可以把二进制数据转换成什么格式的数据，比如String、Json、XML。策略模式其实就是多态的一个淋漓精致的体现。在android中不同Animation动画的实现，主要是依靠Interpolator的不同而实现的。123public void setInterpolator(Interpolator i) &#123; mInterpolator = i;&#125; Template（模板模式）定义：定义一个操作中的算法框架，而将一些步骤延迟到子类中，使得子类可以不改变一个算法的结构即可重定义该算法的某些特定的步骤。实现流程已经确定，实现细节由子类完成。 生命周期对于我们都不陌生，它就是典型的Template模式，在具体流程确定的情况下，至于我们要复写生命周期那些方法，实现那些功能由继承activity的子类去具体实现。关键在于必须有具体的执行流程，比如AsyncTask。 Proxy（代理模式）定义：为其他对象提供一种代理以控制对这个对象的访问。 代理： 在出发点到目的地之间有一道中间层。应用：Android跨进程通信方式 ，建议去了解一下Binder机制。 Interpreter（解释器模式）定义语言的文法，并且建立一个解释器来解释该语言中的句子。比如Android中通过PackageManagerService来解析AndroidManifest.xml中定义的Activity、service等属性。 State（状态模式）行为是由状态来决定的，不同状态下有不同行为。注意：状态模式的行为是平行的、不可替换的，策略模式的行为是彼此独立可相互替换的。体现：不同的状态执行不同的行为，当WIFI开启时，自动扫描周围的接入点，然后以列表的形式展示；当wifi关闭时则清空。 Command（命令模式）我们有很多命令，把它们放在一个下拉菜单中，用户通过先选择菜单再选择具体命令，这就是Command模式。 本来用户(调用者)是直接调用这些命令的，在菜单上打开文档，就直接指向打开文档的代码，使用Command模式，就是在这两者之间增加一个中间者，将这种直接关系拗断，同时两者之间都隔离,基本没有关系了。 显然这样做的好处是符合封装的特性，降低耦合度，有利于代码的健壮性 可维护性 还有复用性。Command是将对行为进行封装的典型模式，Factory是将创建进行封装的模式。android底层逻辑对事件的转发处理就用到了Command模式。 Iterator（迭代模式）提供一种方法顺序访问一个容器对象中的各个元素，而不需要暴露该对象的内部表示。应用：在Java中的Iterator类。Android中的 Cursor。1cursor.moveToFirst(); Composite（组合模式）将对象以树形结构组织起来，以达成“部分－整体” 的层次结构，使得客户端对单个对象和组合对象的使用具有一致性。 Android中View的结构是树形结构，每个ViewGroup包含一系列的View，而ViewGroup本身又是View。这是Android中非常典型的组合模式。 ##1７. Flyweight（共享模式/享元模式） 定义：避免大量拥有相同内容的小类的开销(如耗费内存)，使大家共享一个类(元类)。 面向对象语言的原则就是一切都是对象，但是如果真正使用起来，有时对象数可能显得很庞大，比如，字处理软件，如果以每个文字都作为一个对象，几千个字，对象数就是几千，无疑耗费内存，那么我们还是要”求同存异”，找出这些对象群的共同点，设计一个元类，封装可以被共享的类，另外，还有一些特性是取决于应用(context)，是不可共享的，这也Flyweight中两个重要概念内部状态intrinsic和外部状态extrinsic之分。说白点，就是先捏一个的原始模型，然后随着不同场合和环境，再产生各具特征的具体模型，很显然，在这里需要产生不同的新对象，所以Flyweight模式中常出现Factory模式。Flyweight的内部状态是用来共享的，Flyweight factory负责维护一个Flyweight pool(模式池)来存放内部状态的对象。Flyweight模式是一个提高程序效率和性能的模式，会大大加快程序的运行速度。应用场合很多：比如你要从一个数据库中读取一系列字符串，这些字符串中有许多是重复的，那么我们可以将这些字符串储存在Flyweight池(pool)中。 在Android线程通信中，每次获取Message时调Message.obtain()其实就是从消息池中取出可重复使用的消息，避免产生大量的Message对象。]]></content>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式-单例模式]]></title>
    <url>%2F2018%2F12%2F02%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F-1%2F</url>
    <content type="text"><![CDATA[单例模式(创建型模式):&ensp;单例模式的意图是为了确保一个类有且仅有一个实例，并为它提供一个全局的访问点。优点1、在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例2、避免对资源的多重占用 实现方式饿汉式方式1:1234567891011public class Singleton &#123; //在类内部实例化一个实例 private static Singleton instance = new Singleton(); //私有的构造函数,外部无法访问 private Singleton() &#123; &#125; //对外提供获取实例的静态方法 public static Singleton getInstance() &#123; return instance; &#125;&#125; &ensp;简单的单例的实现，这种实现方式我们称之为饿汉式。所谓饿汉。这是个比较形象的比喻。对于一个饿汉来说，他希望他想要用到这个实例的时候就能够立即拿到，而不需要任何等待时间。所以，通过static的静态初始化方式，在该类第一次被加载的时候实例被创建出来了。这样就保证在第一次想要使用该对象时，他已经被初始化好了。&ensp;由于该实例在类被加载的时候就创建出来了，所以也避免了线程安全问题。方式2123456789101112131415public class Singleton &#123; //在类内部定义 private static Singleton instance; static &#123; //实例化该实例 instance = new Singleton(); &#125; //私有的构造函数,外部无法访问 private Singleton() &#123; &#125; //对外提供获取实例的静态方法 public static Singleton getInstance() &#123; return instance; &#125;&#125; 与方式1是一样的，都是在类被加载的时候实例化一个对象.饿汉式单例，在类被加载的时候对象就会实例化。这也许会造成不必要的消耗，因为有可能这个实例根本就不会被用到。而且，如果这个类被多次加载的话也会造成多次实例化。静态内部类方式12345678910111213public class StaticInnerSingleton &#123; //在静态内部类中初始化实例对象 private static class InnerSingleton &#123; private static final StaticInnerSingleton INSTANCE = new StaticInnerSingleton(); &#125; //私有的构造方法 private StaticInnerSingleton() &#123; &#125; //对外提供获取实例的静态方法 public static final StaticInnerSingleton getInstance() &#123; return InnerSingleton.INSTANCE; &#125;&#125; &ensp;当第一次加载Singleton类时并不会初始化sInstance，只有在第一次调用Singleton的getInstance方法时才会导致 INSTANCE被初始化。因此，第一次调用getInstance方法会导致虚拟机加载SingletonHolder类，这种方式不仅能够 确保线程安全，也能够保证单例对象的唯一性，同时也延迟了单例的实例化，所以这是推荐使用的单例模式实现方式。&ensp;这种方式同样利用了classloder的机制来保证初始化instance时只有一个线程，它跟饿汉式不同的是（很细微的差别）：饿汉式是只要Singleton类被装载了，那么instance就会被实例化（没有达到lazy loading效果），而这种方式是Singleton类被装载了，instance不一定被初始化。因为InnerSingleton类没有被主动使用，只有显示通过调用getInstance方法时，才会显示装载InnerSingleton类，从而实例化instance。想象一下，如果实例化instance很消耗资源，我想让他延迟加载，另外一方面，我不希望在Singleton类加载时就实例化，因为我不能确保Singleton类还可能在其他的地方被主动使用从而被加载，那么这个时候实例化instance显然是不合适的。这个时候，这种方式相比饿汉式更加合理。 懒汉式该对象真正被使用的时候才会实例化的单例模式——懒汉模式。1234567891011121314public class Singleton &#123; //定义实例 private static Singleton instance; //私有构造方法 private Singleton()&#123;&#125; //对外提供获取实例的静态方法 public static Singleton getInstance() &#123; //在对象被使用的时候才实例化 if (instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125;&#125; &ensp;懒汉，就是不会提前把实例创建出来，将类对自己的实例化延迟到第一次被引用的时候。getInstance方法的作用是希望该对象在第一次被使用的时候被new出来。懒汉式单例其实还存在一个问题，那就是线程安全问题。在多线程情况下，有可能两个线程同时进入if语句中，这样，在两个线程都从if中退出的时候就创建了两个不一样的对象。线程安全的懒汉式1234567891011121314public class SynchronizedSingleton &#123; //定义实例 private static SynchronizedSingleton instance; //私有构造方法 private SynchronizedSingleton()&#123;&#125; //对外提供获取实例的静态方法,对该方法加锁 public static synchronized SynchronizedSingleton getInstance() &#123; //在对象被使用的时候才实例化 if (instance == null) &#123; instance = new SynchronizedSingleton(); &#125; return instance; &#125;&#125; &ensp;这种写法能够在多线程中很好的工作，而且看起来它也具备很好的延迟加载，但是，遗憾的是，他效率很低，因为99%情况下不需要同步。（因为上面的synchronized的加锁范围是整个方法，该方法的所有操作都是同步进行的，但是对于非第一次创建对象的情况，也就是没有进入if语句中的情况，根本不需要同步操作，可以直接返回instance。）双重校验锁&ensp;相信对并发编程了解的同学都知道如何解决。其实上面的代码存在的问题主要是锁的范围太大了。只要缩小锁的范围就可以了。那么如何缩小锁的范围呢？相比于同步方法，同步代码块的加锁范围更小。123456789101112131415public class Singleton &#123; private static Singleton singleton; private Singleton() &#123; &#125; public static Singleton getSingleton() &#123; if (singleton == null) &#123; synchronized (Singleton.class) &#123; if (singleton == null) &#123; singleton = new Singleton(); &#125; &#125; &#125; return singleton; &#125;&#125; &ensp;通过使用同步代码块的方式减小了锁的范围。这样可以大大提高效率。（对于已经存在singleton的情况，无须同步，直接return）。但是，事情这的有这么容易吗？上面的代码看上去好像是没有任何问题。实现了惰性初始化，解决了同步问题，还减小了锁的范围，提高了效率。但是，该代码还存在隐患。隐患的原因主要和Java内存模型（JMM）有关。考虑下面的事件序列：1、 线程A发现变量没有被初始化, 然后它获取锁并开始变量的初始化。2、 由于某些编程语言的语义，编译器生成的代码允许在线程A执行完变量的初始化之前，更新变量并将其指向部分初始化的对象。3、 线程B发现共享变量已经被初始化，并返回变量。由于线程B确信变量已被初始化，它没有获取锁。如果在A完成初始化之前共享变量对B可见（这是由于A没有完成初始化或者因为一些初始化的值还没有穿过B使用的内存(缓存一致性)），程序很可能会崩溃。假设线程A执行到sInstance = new Singleton()语句，这里看起来是一句代码，但实际上它并不是一个原子操作， 这句代码最终会被编译成多条汇编指令，它大致做了3件事情：1、 给Singleton的实例分配内存；2、 调用Singleton()的构造函数，初始化成员字段；3、 将sInstance对象指向分配的内存空间（此时sInstance就不是null了）。&ensp;但是，由于Java编译器允许处理器乱序执行，以及JDK1.5之前JMM（Java Memory Model，即Java内存模型）中 Cache、寄存器到主内存回写顺序的规定，上面的第二和第三的顺序是无法保证的。也就是说，执行顺序可能是1-2-3也可能是1-3-2。如果是后者，并且在3执行完毕、2未执行之前，被切换到线程B上， 这时候sInstance因为己经在线程A内执行过了第三点，sInstance己经是非空了，所以，线程B直接取走sInstance， 再使用时就会出错，这就是DCL失效问题，而且这种难以跟踪难以重现的错误很可能会隐藏很久。&ensp;在J2SE 1.4或更早的版本中使用双重检查锁有潜在的危险，有时会正常工作（区分正确实现和有小问题的实现是很困难的。取决于编译器，线程的调度和其他并发系统活动，不正确的实现双重检查锁导致的异常结果可能会间歇性出现。重现异常是十分困难的。） 在J2SE 5.0中，这一问题被修正了。volatile关键字保证多个线程可以正确处理单件实例使用volatile123456789101112131415public class VolatileSingleton &#123; private static volatile VolatileSingleton singleton; private VolatileSingleton() &#123; &#125; public static VolatileSingleton getSingleton() &#123; if (singleton == null) &#123; synchronized (VolatileSingleton.class) &#123; if (singleton == null) &#123; singleton = new VolatileSingleton(); &#125; &#125; &#125; return singleton; &#125;&#125; &ensp;上面这种双重校验锁的方式用的比较广泛，他解决了前面提到的所有问题。但是，即使是这种看上去完美无缺的方式也可能存在问题，那就是遇到序列化的时候。使用final123456class FinalWrapper&lt;T&gt; &#123; public final T value; public FinalWrapper(T value) &#123; this.value = value; &#125;&#125; 123456789101112131415public class FinalSingleton &#123; private FinalWrapper&lt;FinalSingleton&gt; helperWrapper = null; public FinalSingleton getHelper() &#123; FinalWrapper&lt;FinalSingleton&gt; wrapper = helperWrapper; if (wrapper == null) &#123; synchronized (this) &#123; if (helperWrapper == null) &#123; helperWrapper = new FinalWrapper&lt;FinalSingleton&gt;(new FinalSingleton()); &#125; wrapper = helperWrapper; &#125; &#125; return wrapper.value; &#125;&#125; 枚举式12345public enum Singleton &#123; INSTANCE; public void Singleton() &#123; &#125;&#125; &ensp;这种方式是Effective Java作者Josh Bloch 提倡的方式，它不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象。写法简单是枚举单例最大的有点，枚举在Java中与普通的类是一样的，不仅能够有字段，还能够有自己的方法。最重要的是默认枚举实例的创建是线程安全的，并且在任何情况下都是一个单例。&ensp;为什么这么说呢？在上述几种单例模式实现中，在一个情况下它们会出现重新创建对象的情况，那就是反序列化。&ensp;通过序列化可以将一个单例的实例对象写到磁盘，然后再读回来，从而有效的获得一个实例。即使构造函数是私有的，反序列化时依然可以通过特殊的途径去创建类的一个新的实例，相当于调用该类的构造函数。反序列化操作提供了一个很特别的钩子函数，类中具有一个私有的、被实例化的方法readResolve()，这个方法可以让开发人员控制对象的反序列化。&ensp;要想防止序列化对单例的破坏，只要在Singleton类中定义readResolve就可以解决该问题：1234567891011121314151617public class Singleton implements Serializable&#123; private volatile static Singleton singleton; private Singleton ()&#123;&#125; public static Singleton getSingleton() &#123; if (singleton == null) &#123; synchronized (Singleton.class) &#123; if (singleton == null) &#123; singleton = new Singleton(); &#125; &#125; &#125; return singleton; &#125; private Object readResolve() throws ObjectStreamException&#123; return singleton; &#125;&#125;]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式-设计模式概述]]></title>
    <url>%2F2018%2F12%2F02%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[设计模式的六大原则开闭原则（Open Close Principle）开闭原则就是说对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。 里氏代换原则（Liskov Substitution Principle）里氏代换原则(Liskov Substitution Principle LSP)面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。 LSP是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。里氏代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。 依赖倒转原则（Dependence Inversion Principle）这个是开闭原则的基础，具体内容：真对接口编程，依赖于抽象而不依赖于具体。 接口隔离原则（Interface Segregation Principle）这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。还是一个降低类之间的耦合度的意思，从这儿我们看出，其实设计模式就是一个软件的设计思想，从大型软件架构出发，为了升级和维护方便。所以上文中多次出现：降低依赖，降低耦合。 迪米特法则（最少知道原则）（Demeter Principle）为什么叫最少知道原则，就是说：一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。 合成复用原则（Composite Reuse Principle）合成复用原则是尽量使用合成/聚合的方式，而不是使用继承。其中前四种也是面向对象的四个基本原则。 设计模式分类设计模式分为5种类型:接口型模式: 适配器模式、外观模式 、合成模式、桥接模式指责型模式: 单例模式、观察者模式、调停者模式、代理模式、职责链模式、享元模式构造型模式: 构建着模式、工厂方法模式、抽象工厂模式、原型模式、备忘录模式操作型模式: 模板方法模式、状态模式、策略模式、命令模式、解释器模式扩展型模式: 装饰器模式、迭代器模式、访问者模式。 设计模式简单介绍抽象工厂模式（Abstract Factory）: 提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。适配器模式（Adapter）: 将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。桥接模式（Bridge）: 将抽象部分与它的实现部分分离，使它们都可以独立地变化。建造者模式（Builder）: 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。责任链模式（Chain of Responsibility）: 为解除请求的发送者和接收者之间耦合，而使多个对象都有机会处理这个请求。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它。命令模式（Command）: 将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可取消的操作。组合模式（Composite）: 将对象组合成树形结构以表示“部分-整体”的层次结构。它使得客户对单个对象和复合对象的使用具有一致性。装饰模式（Decorator）: 动态地给一个对象添加一些额外的职责。就扩展功能而言， 它比生成子类方式更为灵活。外观模式（Facade）: 为子系统中的一组接口提供一个一致的界面，Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。工厂模式（Factory Method）: 定义一个用于创建对象的接口，让子类决定将哪一个类实例化。Factory Method使一个类的实例化延迟到其子类。享元模式（Flyweight）: 运用共享技术有效地支持大量细粒度的对象。解析器模式（Interpreter）: 给定一个语言, 定义它的文法的一种表示，并定义一个解释器, 该解释器使用该表示来解释语言中的句子。迭代器模式（Iterator）: 提供一种方法顺序访问一个聚合对象中各个元素，而又不需暴露该对象的内部表示。中介模式（Mediator）: 用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。备忘录模式（Memento）: 在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到保存的状态。观察者模式（Observer）: 定义对象间的一种一对多的依赖关系,以便当一个对象的状态发生改变时,所有依赖于它的对象都得到通知并自动刷新。原型模式（Prototype）: 用原型实例指定创建对象的种类，并且通过拷贝这个原型来创建新的对象。代理模式（Proxy）: 为其他对象提供一个代理以控制对这个对象的访问。单例模式（Singleton）: 保证一个类仅有一个实例，并提供一个访问它的全局访问点。状态模式（State）: 允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它所属的类。策略模式（Strategy）: 定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。本模式使得算法的变化可独立于使用它的客户。模板方法模式（Template Method）: 定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。Template Method使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。访问者模式（Visitor）: 表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
</search>
